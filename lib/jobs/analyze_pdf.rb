require 'open3'
require_relative '../../tabula_job_executor/executor.rb'

require_relative '../jruby_dump_characters.rb'

module JRubyProgressObserver
  def update(*args)
    self.at(*args)
  end
end

class AnalyzePDFJob < Tabula::Background::Job
  # args: (:file_id, :file, :output_dir, :sm_thumbnail_job, :lg_thumbnail_job)
  # Runs the jruby PDF analyzer on the uploaded file.

  def perform_in_mri
    file_id = options['file_id']
    file = options['file']
    output_dir = options['output_dir']

    # open a subprocess and catch input/output/stderr (and a reference
    # to our thread that watches it). this opens asynchronously
    # so we can continually handle the output stream.
    _stdin, _stdout, _stderr, thr = Open3.popen3(
        {"CLASSPATH" => "lib/jars/pdfbox-app-1.8.0.jar"},
        "#{Settings::JRUBY_PATH} --1.9 --server lib/jruby_dump_characters.rb #{file} #{output_dir}"
    )

    # handle stderr (which is where we are "printing" the page number
    # status -- see near bottom of libs/jruby_dump_characters.rb)
    _stderr.each { |line|
      progress, total = line.split('///', 2)

      if progress.nil? || total.nil?
        # TODO: some PDF files will result in warnings generated by
        #       pdfbox. right now we'll just skip them (and pass them
        #       on to the user).
        STDERR.puts(line)
        next
      end

      progress = (progress.strip).to_i
      total = (total.strip).to_i
      if total === 0
        total = 1
      end

      #puts "#{progress} of #{total} (#{converted_progress}%)"
      at(progress, total+2, "processing page #{progress} of #{total}...",
         'file_id' => file_id,
         'upload_id' => upload_id
         )
    }
    _stdin.close
    _stdout.close
    _stderr.close

    # catch exit code of jruby/pdfbox process
    # TODO: if fail, should probably do something useful with stderr
    # TODO: if fail, should clean up upload directory
    exit_status = thr.value.exitstatus
    if exit_status != 0
      failed(
             'file_id' => file_id,
             'upload_id' => upload_id
             )
      return nil
    end
  end

  def perform_in_jruby
    Thread.new {
      xg = XMLGenerator.new(options['file'],
                            options['output_dir'])
      xg.add_observer(self, :at)
    }.join
  end

  def perform
    file_id = options['file_id']
    sm_thumbnail_job = options['sm_thumbnail_job']
    lg_thumbnail_job = options['lg_thumbnail_job']
    upload_id = self.uuid

    # return some status to browser
    at(0, 100, "analyzing PDF text...",
      'file_id' => file_id,
      'upload_id' => upload_id,
      'thumbnails_complete' => true
    )

    unless defined? JRUBY_VERSION
      perform_in_mri
    else
      perform_in_jruby
    end

    # If thumbnail jobs haven't finished, wait up for them
    while (!Tabula::Background::JobExecutor.get(sm_thumbnail_job).completed? || !Tabula::Background::JobExecutor.get(lg_thumbnail_job).completed?) do
      at(99, 100, "generating thumbnails...",
         'file_id' => file_id,
         'upload_id' => upload_id
         )
      sleep 0.25
    end

    at(100, 100, "complete",
       'file_id' => file_id,
       'upload_id' => upload_id,
       'thumbnails_complete' => true
       )

    return nil

  end
end
